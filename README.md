# vk-shader-macros

[![Documentation](https://docs.rs/vk-shader-macros/badge.svg)](https://docs.rs/vk-shader-macros/)
[![Crates.io](https://img.shields.io/crates/v/vk-shader-macros.svg)](https://crates.io/crates/vk-shader-macros)
[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](LICENSE-MIT)
[![License: Apache 2.0](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](LICENSE-APACHE)

A procedural macro for compiling GLSL into SPIR-V constants.

## Examples

```rust
static VERT: ShaderData = include_glsl!("shaders/example.vert");
static FRAG: ShaderData = include_glsl!("shaders/example.glsl", kind: frag);
static RGEN: ShaderData = include_glsl!("shaders/example.rgen", target: vulkan1_2); // vulkan1_2 is required to build with GL_EXT_ray_tracing

fn create_pipelines() {
    // returns `impl Deref<Target = [u32]>`
    let vertex_data = VERT.data();

    // bypass runtime compilation when the `hot-reloading` feature is enabled
    let vertex_data: &'static [u32] = VERT.compile_time_spv;
}
```

Debug info is generated by default; pass `strip` to the macro to omit
it, or build the crate with the `strip` feature enabled.

## Why `[u32]`?

SPIR-V is a stream of 32-bit words, not bytes, and this is reflected
in APIs that consume it. In particular, passing a `[u8]` of SPIR-V
that is not 4-byte-aligned to Vulkan is undefined behavior. Storing
SPIR-V in its native format guarantees that this will never occur,
without requiring copying or unsafe code.

## Hot-Reloading

The `hot-reloading` feature allows re-compiling shaders at runtime.
Calling `ShaderData::data` will try to compile the shader again if any of its source files have changed.
It always returns the latest successful compilation. Errors are logged to the standard error.

`vk_shader_macros::should_recompile()` returns a `bool` that indicates if *any* shaders have changed since the last time
the function was called.

## Dependencies

This crate currently depends on the foreign
[shaderc](https://github.com/google/shaderc/) library. By default, it
will attempt to use an installed shaderc library. However if it does
not exist, it will fall back to building from source, requiring git,
cmake, python 3, and a supported C++ compiler to be available in the
build environment. When using a pre-compiled shaderc, care must be
taken to use a version that is binary-compatible with the one checked
out by [the shaderc crate](https://github.com/google/shaderc-rs).
You can force shaderc to be built from source by enabling the
`build-from-source` feature on vk-shader-macros.